{"pages":[{"title":"About","text":"","link":"/about/index.html"}],"posts":[{"title":"Climbing Stairs","text":"You are climbing a staircase. It takes n steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? 来源：力扣（LeetCode） 12345Input: n = 2Output: 2Explanation: There are two ways to climb to the top.1. 1 step + 1 step2. 2 steps 123456Input: n = 3Output: 3Explanation: There are three ways to climb to the top.1. 1 step + 1 step + 1 step2. 1 step + 2 steps3. 2 steps + 1 step 超时解法：无脑递归1234567891011public class climbStairs { public static int climbStairs(int n) { if (n == 1) return 1; if (n == 2) return 2; return climbStairs(n - 1) + climbStairs(n - 2); } public static void main(String[] args) { System.out.println(climbStairs(4)); }} 时间复杂度：$O(2^n)$ （每层递归的complexity是上一层的2倍）空间复杂度：$O(n)$ （递归层数） 为什么这里空间复杂度是O(n)? 递归的空间复杂度是：递归的深度*每次递归所需的辅助空间的个数 辅助空间指的是为局部变量和形参所开辟的空间，对于递归算法，由于运行时有附加堆栈，所以递归的空间复杂度是递归的深度*每次压栈所需的空间个数。 递归有运行时堆栈，求的是递归最深的那一次压栈所耗费的空间的个数递归最深的那一次所耗费的空间足以容纳它所有递归过程。（递归是要返回上一层的，所以它所需要的空间不是一直累加起来的） 所以最深的那次压栈就是递归的空间复杂度。递归的深度是n，而每次递归所需的辅助空间个数为1。 由上图可知，很多节点重复求解多次，所以可以使用HashMap来保存求解过程中已经求过的值。 HashMap12345678910111213141516171819202122import java.util.HashMap;import java.util.Map;public class climbStairs { private static Map&lt;Integer, Integer&gt; storeMap = new HashMap&lt;&gt;(); public static int climbStairs(int n) { if (n == 1) return 1; if (n == 2) return 2; if (storeMap.get(n) != null) { return storeMap.get(n); } else { int result = climbStairs(n - 1) + climbStairs(n - 2); storeMap.put(n, result); return result; } } public static void main(String[] args) { System.out.println(climbStairs(4)); }} 时间复杂度：O(n) （链表）空间复杂度：O(n) （存储桶，链表） JDK1.8之前，HashMap底层实现用的是数组+链表，HashMap通过hash计算key的哈希值，然后hash%n（n为数组长度，初始化数组默认长度为16），得到key在数组中存放的下标；当出现哈希冲突时（两个key在数组中存放的下标一致），数据以链表形式存储；在链表中查找数据必须从第一个元素开始一层一层地往下找，直到找到为止，时间复杂度为O(n)，所以当链表长度越来越长时，HashMap的效率越来越低。 JDK1.8之后，corporate into了红黑树，当链表中的元素超过8（TREEIFY_THRESHOLD），并且数组长度大于64（MIN_TREEIFY_CAPACITY）时，会将链表转换为红黑树，转换之后数据查询的时间复杂度从O(n)降至O(logn)。 递归转循环12345678910111213public static int climbStairs(int n) { if (n == 1) return 1; if (n == 2) return 2; int result = 0; int pre = 2; int prePre = 1; for (int i = 3; i &lt;= n; ++i) { result = pre + prePre; prePre = pre; pre = result; } return result;} 时间复杂度：O(n)空间复杂度：O(1) （辅助空间是常数级别的）","link":"/2022/08/29/Climbing-Stairs/"},{"title":"Reverse Linked List","text":"Given the head of a singly linked list, reverse the list, and return the reversed list. 12Input: head = [1,2,3,4,5]Output: [5,4,3,2,1] 来源：力扣（LeetCode） 双指针迭代： 定义双指针：pre 和 cur 局部反转：cur.next=pre pre 和 cur 同时右移一个位置 循环上述过程，直至 cur 到达链表尾部 123456789101112131415161718192021222324252627282930313233343536373839404142public class reverseNode { public static class ListNode { int val; ListNode next; ListNode(int val, ListNode next) { this.val = val; this.next = next; } } public static ListNode reverseList(ListNode head) { ListNode pre = null; ListNode cur = head; while (cur != null) { ListNode tmp = cur.next; cur.next = pre; pre = cur; cur = tmp; } return pre; } public static void printList(ListNode head) { ListNode cur = head; while (cur != null) { System.out.printf(\"%d \", cur.val); cur = cur.next; } } public static void main(String[] args) { ListNode node5 = new ListNode(5, null); ListNode node4 = new ListNode(4, node5); ListNode node3 = new ListNode(3, node4); ListNode node2 = new ListNode(2, node3); ListNode node1 = new ListNode(1, node2); ListNode pre = reverseList(node1); printList(pre); }} 时间复杂度：O(n)空间复杂度：O(1) 双指针迭代：另一种思路，充分运用head头节点 12345678910111213public static ListNode reverseList(ListNode head) { if (head == null) { return null; } ListNode cur = head; while (head.next != null) { ListNode tmp = head.next.next; head.next.next = cur; cur = head.next; head.next = tmp; } return cur;} 时间复杂度：O(n)空间复杂度：O(1) 递归： 使用递归函数，一直递归到链表的最后一个结点，该结点就是反转后的头结点，记作 cur 此后，每次函数在返回的过程中，让当前结点的下一个结点的 next 指针指向当前节点 同时让当前结点的 next 指针指向 NULL ，从而实现从链表尾部开始的局部反转 当递归函数全部出栈后，链表反转完成 123456789public static ListNode reverseList(ListNode head) { if (head == null || head.next == null) { return head; } ListNode cur = reverseList(head.next); head.next.next = head; head.next = null; return cur;} 时间复杂度：O(n)空间复杂度：O(n) 空间复杂度指的是执行算法需要的辅助存储空间相对于数据规模的增长关系，算的是变量的个数，对于递归程序，每递归一次都在栈上开辟一块内存，所以递归了多少次就开辟了多少块内存，开辟的那些内存就是空间复杂度，因为递归了n次，所以递归的空间复杂度为O(n)。","link":"/2022/08/29/Reverse%20Linked%20List/"},{"title":"Linked List Cycle","text":"Given head, the head of a linked list, determine if the linked list has a cycle in it. There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the&nbsp;next&nbsp;pointer. Internally, pos&nbsp;is used to denote the index of the node that&nbsp;tail’s&nbsp;next&nbsp;pointer is connected to.&nbsp;Note that&nbsp;pos&nbsp;is not passed as a parameter. Return&nbsp;true if there is a cycle in the linked list. Otherwise, return false. 来源：力扣（LeetCode） 123输入：head = [3,2,0,-4], pos = 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。 123输入：head = [1,2], pos = 0输出：true解释：链表中有一个环，其尾部连接到第一个节点。 123输入：head = [1], pos = -1输出：false解释：链表中没有环。 进阶：你能用 O(1)（即，常量）内存解决此问题吗？ 快慢指针：跑的快的总能套圈12345678910111213141516171819202122232425262728293031323334353637public class LinkedListCycle { public static class ListNode { int val; ListNode next; ListNode(int x) { val = x; next = null; } } public static boolean hasCycle(ListNode head) { if (head == null) return false; ListNode slowPtr = head, fastPtr = head; while (fastPtr.next != null &amp;&amp; fastPtr.next.next != null) { slowPtr = slowPtr.next; fastPtr = fastPtr.next.next; if (slowPtr == fastPtr) return true; } return false; } public static void main(String[] args) { ListNode node1 = new ListNode(3); ListNode node2 = new ListNode(2); ListNode node3 = new ListNode(0); ListNode node4 = new ListNode(-4); node1.next = node2; node2.next = node3; node3.next = node4; node4.next = node2; System.out.println(hasCycle(node1)); }} 时间复杂度：O(n) （n为链表中的节点数）空间复杂度：O(1) （只使用了两个指针的额外空间） 当链表中不存在环时，快指针将先于慢指针到达链表尾部，链表中每个节点至多被访问两次。当链表中存在环时，每一轮移动后，快慢指针的距离将减小一。而初始距离为环的长度，因此至多移动 n 轮。 HashSet不重复的添加，添加元素时会判断是否已经存在,已经存在会添加不成功 1234567891011121314151617181920212223242526272829303132333435363738394041import java.util.HashSet;import java.util.Set;public class LinkedListCycle { public static class ListNode { int val; ListNode next; ListNode(int x) { val = x; next = null; } } public static boolean hasCycle(ListNode head) { Set seen = new HashSet(); while (head != null) { if (!seen.add(head)) return true; head = head.next;// if (seen.contains(head)) return true;// seen.add(head);// head = head.next; } return false; } public static void main(String[] args) { ListNode node1 = new ListNode(3); ListNode node2 = new ListNode(2); ListNode node3 = new ListNode(0); ListNode node4 = new ListNode(-4); node1.next = node2; node2.next = node3; node3.next = node4; node4.next = node2; System.out.println(hasCycle(node1)); }} 时间复杂度：O(n) （n为链表中节点数）空间复杂度：O(n) （主要为哈希表的开销，最坏情况下我们需要将每个节点插入到哈希表中一次） https://blog.csdn.net/weixin_45453739/article/details/122644349 Relevant Problem给定一个链表的头节点 head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 不允许修改链表。 123输入：head = [3,2,0,-4], pos = 1输出：返回索引为 1 的链表节点解释：链表中有一个环，其尾部连接到第二个节点。 123输入：head = [1,2], pos = 0输出：返回索引为 0 的链表节点解释：链表中有一个环，其尾部连接到第一个节点。 123输入：head = [1], pos = -1输出：返回 null解释：链表中没有环。 进阶：你是否可以使用 O(1) 空间解决此题？ 快慢指针： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class LinkedListCycle { public static class ListNode { int val; ListNode next; ListNode(int x) { val = x; next = null; } } public static ListNode detectCycle(ListNode head) { if (head == null) return null; ListNode tortoise = head, rabbit = head; boolean loopExists = false; while (rabbit.next != null &amp;&amp; rabbit.next.next != null) { tortoise = tortoise.next; rabbit = rabbit.next.next; if (tortoise == rabbit) { loopExists = true; break; } } if (loopExists == true) { tortoise = head; while (tortoise != rabbit) { tortoise = tortoise.next; rabbit = rabbit.next; } return tortoise; } return null; } public static void main(String[] args) { ListNode node1 = new ListNode(3); ListNode node2 = new ListNode(2); ListNode node3 = new ListNode(0); ListNode node4 = new ListNode(-4); node1.next = node2; node2.next = node3; node3.next = node4; node4.next = node2; System.out.println(detectCycle(node1).val); }}","link":"/2022/08/29/Linked-List-Cycle/"},{"title":"Merge Two Sorted Lists","text":"You are given the heads of two sorted linked lists list1 and list2. Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists. Return the head of the merged linked list. 来源：力扣（LeetCode） 12Input: list1 = [1,2,4], list2 = [1,3,4]Output: [1,1,2,3,4,4] 12Input: list1 = [], list2 = []Output: [] 12Input: list1 = [], list2 = [0]Output: [0] 循环+双指针12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class mergeTwoSortedLists { public static class ListNode { int val; ListNode next; ListNode(int val) { this.val = val; } } public static ListNode mergeTwoLists(ListNode list1, ListNode list2) { ListNode resultNode = new ListNode(0); ListNode p = resultNode; while (list1 != null &amp;&amp; list2 != null) { if (list1.val &lt; list2.val) { p.next = list1; list1 = list1.next; } else { p.next = list2; list2 = list2.next; } p = p.next; } if (list1 != null) p.next = list1; if (list2 != null) p.next = list2; return resultNode.next; } public static void main(String[] args) { ListNode node1 = new ListNode(1); ListNode node2 = new ListNode(1); ListNode node3 = new ListNode(2); ListNode node4 = new ListNode(3); ListNode node5 = new ListNode(4); ListNode node6 = new ListNode(4); node1.next = node3; node3.next = node5; node2.next = node4; node4.next = node6; ListNode node = mergeTwoLists(node1, node2); while (node != null) { System.out.print(node.val + \" \"); node = node.next; } }} 时间复杂度：O(n+m)空间复杂度：O(1) 递归12345678910public static ListNode mergeTwoLists(ListNode list1, ListNode list2) { if (list1 == null) return list2; if (list2 == null) return list1; if (list1.val &lt; list2.val) { list1.next = mergeTwoLists(list1.next, list2); return list1; } list2.next = mergeTwoLists(list1, list2.next); return list2;} 时间复杂度：O(n+m)空间复杂度：O(n+m)","link":"/2022/08/29/Merge%20Two%20Sorted%20Lists/"}],"tags":[{"name":"Two pointers","slug":"Two-pointers","link":"/tags/Two-pointers/"},{"name":"Iterative","slug":"Iterative","link":"/tags/Iterative/"},{"name":"Recursion","slug":"Recursion","link":"/tags/Recursion/"},{"name":"HashMap","slug":"HashMap","link":"/tags/HashMap/"}],"categories":[{"name":"DataStructure","slug":"DataStructure","link":"/categories/DataStructure/"}]}